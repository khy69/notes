# os|6.s081|intoduction

## 目标

- 设计和实现操作系统
- 扩展或优化操作系统

## 操作系统本身

- 抽象硬件，管理硬件资源且方便用户使用
- 隔离进程，使他们可以共享硬件资源-multiplex，同时不互相干扰
- 提供功能，使得进程之间可以共享信息，写作完成功能
- 用户通过简单的开发和调用，可以借助操作系统这一工具，榨取硬件的性能
- 通用的操作系统：在不同特点的进程之间形成balance，提供相对各种process都友好的平台

## 整体结构

- 用户态程序
- 内核态程序

![](/Users/khy/Documents/cs/notes/os/imgs/os-architecture.png)

重点关注：kernel

- 管理所有的用户空间进程，分配和维护硬件资源
- 作为用户和硬件打交道的一个中间人，抽象硬件，处理来自用户的底层请求
- three pieces：虚拟化，持久化，并发

### 进程(虚拟化)

每一个正在运行的用户态空间程序

- 独立的内存空间和共享的硬件信息(e.gCPU时间)

### 文件系统(持久化)

维护文件信息到磁盘位置的一个映射

### security

- 用户的非法请求
- stack overflow
- ...

### shell

用户与机器交互的接口

- 输入命令->命令shell运行某个程序
- 重定向（本质上也是一种用户程序级别的实现）：将上一个命令的输出（入）作为下一个命令的输入（出）
  - e.g：`grep x < out`，out作为输入到grep

- 执行命令：`fork`-> `exec`:加载制定文件中的指令，替代当前进程的剩余所有指令
  - **保存进程的fd表单**
  - 使用0（null）表示参数列表终止
  - shell永不终止，先fork一个子进程，再使用exec执行新命令

- I/O重定向：默认情况下，进程会输出到fd==1（标准输出）。若想输出到另一个“文件“，只需要改变表单中的映射即可

  - 具体实现：

    ~~~c++
    close(1);
    open(file,...)
    ~~~

    在open时，会将文件映射到最小的fd，由于0默认是控制台输入，所以下一次一定会返回1

### syscall

用户程序与内核进行交互的API

- 与用户态的普通函数类似，但是从用户态进入内核态中运行，得到结果后返回给用户态
- 进入系统调用：在RISC-V中，通过特定的`ecall`机器指令，从user转入kernel
- open:根据调用参数以特定权限打开某文件，返回file descriptor（方便用户描述和使用某个文件的标志）
- fork:创建一个与当前进程完全相同的子进程，将当前进程的所有内存中的内容（指令和数据）都完全复制一遍成为一个新的进程，新进程的pc与原进程指向同样的指令
  - 父进程：返回子进程的pid（>0）
  - 子进程：返回0
  - **区分两个进程**
  - 两块独立的内存地址空间，其余内容完全一致（包括fd）
- read：从fd读bytes到某个内存处
  - shell默认：fd 0 标准输入；1:标准输出
- open:创建文件描述符（抽象：包括各种可以被用于读取和输出的地方，而不单指传统的“文件”）；第二个参数：表示当前进程对文件的权限
  - 文件描述符：每个进程都有一个表单，上面记录着映射fd->“文件”，进程可以通过fd来访问文件；不同进程之间的表单相互独立

- wait：父进程等待任何一个子进程退出，子进程通过exit的退出参数可以传递到wait的参数中，从而达成一种交互
  - 无法让子进程等待父进程，若无子进程，wait立即返回-1
  - 当有多个子进程，wait会在一个子进程退出后立即返回其进程号，所以**多个子进程需要使用多个wait来等待**
